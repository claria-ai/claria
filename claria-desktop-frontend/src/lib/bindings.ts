// @ts-nocheck

// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/


export const commands = {
async hasConfig() : Promise<Result<boolean, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("has_config") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async loadConfig() : Promise<Result<ConfigInfo, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("load_config") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async saveConfig(region: string, systemName: string, accountId: string, credentials: CredentialSource) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("save_config", { region, systemName, accountId, credentials }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async deleteConfig() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_config") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Assess the provided credentials: validates them via STS and classifies
 * them as root / IAM admin / scoped Claria / insufficient.
 * 
 * The desktop app uses the returned `CredentialAssessment` to decide
 * which UI flow to present (bootstrap vs. straight to provisioning).
 */
async assessCredentials(region: string, credentials: CredentialSource) : Promise<Result<CredentialAssessment, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("assess_credentials", { region, credentials }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Assume a role in an AWS sub-account using parent-account credentials.
 * 
 * The operator provides their parent-account credentials and the sub-account
 * details. We call STS AssumeRole and return temporary credentials that can
 * be used with `assess_credentials` and `bootstrap_iam_user` to set up a
 * dedicated IAM user in the sub-account.
 * 
 * The temporary credentials are never persisted to disk.
 */
async assumeRole(region: string, credentials: CredentialSource, accountId: string, roleName: string) : Promise<Result<AssumeRoleResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("assume_role", { region, credentials, accountId, roleName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async listAwsProfiles() : Promise<Result<string[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_aws_profiles") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * List all access keys for the `claria-admin` IAM user, enriched with
 * last-used metadata.
 * 
 * Called when bootstrap fails due to the 2-key limit so the operator can
 * pick which key to delete.
 */
async listUserAccessKeys(region: string, credentials: CredentialSource) : Promise<Result<AccessKeyInfo[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_user_access_keys", { region, credentials }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Delete one access key belonging to the `claria-admin` IAM user.
 * 
 * Called after the operator picks a key to remove to make room for a
 * fresh one during bootstrap.
 */
async deleteUserAccessKey(region: string, credentials: CredentialSource, accessKeyId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_user_access_key", { region, credentials, accessKeyId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Run the full bootstrap flow: create a scoped IAM user and policy using
 * the operator's current (broad) credentials, then persist the new scoped
 * credentials to the local config.
 * 
 * The provisioner does all the IAM work and returns the new credentials.
 * We handle only the config write and in-memory state update.
 */
async bootstrapIamUser(region: string, systemName: string, rootAccessKeyId: string, rootSecretAccessKey: string, sessionToken: string | null, credentialClass: CredentialClass) : Promise<Result<BootstrapResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("bootstrap_iam_user", { region, systemName, rootAccessKeyId, rootSecretAccessKey, sessionToken, credentialClass }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Update the `ClariaProvisionerAccess` IAM policy using temporary elevated
 * credentials (root or admin).
 * 
 * The dashboard calls this when the manifest changes and requires IAM actions
 * not in the current policy. The elevated credentials are used once and
 * discarded — they are never persisted to disk.
 */
async escalateIamPolicy(accessKeyId: string, secretAccessKey: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("escalate_iam_policy", { accessKeyId, secretAccessKey }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Scan all resources and return an annotated plan.
 * 
 * This is always the first call — both onboarding and dashboard use it.
 * The plan is a flat `Vec<PlanEntry>`, each carrying the full spec plus
 * action/cause/drift so the frontend has everything it needs.
 */
async plan() : Promise<Result<PlanEntry[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("plan") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Execute all actionable entries in the plan.
 * 
 * Returns the updated plan (all entries should now be Ok).
 */
async apply() : Promise<Result<PlanEntry[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("apply") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Destroy all managed resources. Returns nothing on success.
 */
async destroy() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("destroy") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Delete the provisioner state file (local + S3) so the next scan starts fresh.
 * 
 * Use this when state is incompatible with the current version of Claria.
 * AWS resources are not affected — the next scan will re-discover them.
 */
async resetProvisionerState() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("reset_provisioner_state") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * List all client records from S3.
 * 
 * Loads each `clients/{id}.json` object, deserializes the Client, and
 * returns summaries sorted by most recently created first.
 */
async listClients() : Promise<Result<ClientSummary[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_clients") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Create a new client record in S3.
 */
async createClient(name: string) : Promise<Result<ClientSummary, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_client", { name }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Delete a client and all associated data (record files, chat history).
 */
async deleteClient(clientId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_client", { clientId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * List files in a client's record, excluding sidecar `.text` files.
 */
async listRecordFiles(clientId: string) : Promise<Result<RecordFile[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_record_files", { clientId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Upload a file to a client's record from a local file path.
 * 
 * If the file is a PDF or DOCX, a sidecar `.text` file is generated
 * via Bedrock document text extraction and uploaded alongside.
 */
async uploadRecordFile(clientId: string, filePath: string) : Promise<Result<RecordFile, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("upload_record_file", { clientId, filePath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Delete a file from a client's record, including its sidecar if present.
 */
async deleteRecordFile(clientId: string, filename: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_record_file", { clientId, filename }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get the text content for a record file.
 * 
 * For plain text files (`.txt`), returns the file content directly.
 * For other files, returns the `.text` sidecar content if available.
 */
async getRecordFileText(clientId: string, filename: string) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_record_file_text", { clientId, filename }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Create a plain text file in a client's record.
 * 
 * Writes the given content as a `.txt` file directly to S3. If the filename
 * doesn't already end in `.txt`, it is appended.
 */
async createTextRecordFile(clientId: string, filename: string, content: string) : Promise<Result<RecordFile, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_text_record_file", { clientId, filename, content }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Update the content of an existing plain text file in a client's record.
 */
async updateTextRecordFile(clientId: string, filename: string, content: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_text_record_file", { clientId, filename, content }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Load text content for all record files belonging to a client.
 * 
 * For `.txt` files, returns the file content directly. For PDF/DOCX,
 * returns the `.text` sidecar content if available. Files with no
 * readable text are omitted.
 */
async listRecordContext(clientId: string) : Promise<Result<RecordContext[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_record_context", { clientId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * List available Anthropic Claude models for chat.
 * 
 * Queries Bedrock for system-defined inference profiles and returns
 * those matching Anthropic Claude models.
 */
async listChatModels() : Promise<Result<ChatModel[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_chat_models") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Send a chat message to Bedrock and return the assistant's response.
 * 
 * The frontend maintains the full conversation history and sends it
 * with each request so the model has context. The system prompt is
 * fetched from S3 on each call so edits take effect immediately.
 * Record context (text from the client's files) is loaded from S3
 * and prepended to the system prompt.
 * 
 * After each successful exchange, the full conversation is persisted
 * to S3 under `records/{client_id}/chat-history/{chat_id}.json`.
 * The `chat_id` is generated on the first message and returned so the
 * frontend can pass it back on subsequent calls.
 */
async chatMessage(clientId: string, modelId: string, messages: ChatMessage[], chatId: string | null) : Promise<Result<ChatResponse, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("chat_message", { clientId, modelId, messages, chatId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Accept the Marketplace agreement for a Bedrock foundation model.
 * 
 * Called when a model requires an agreement before it can be used.
 * The frontend can detect this from the error message and offer
 * a one-click accept flow.
 */
async acceptModelAgreement(modelId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("accept_model_agreement", { modelId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Load a chat history session from S3.
 * 
 * Returns the full conversation with model ID so the frontend can
 * resume the session in the Chat widget.
 */
async loadChatHistory(clientId: string, chatId: string) : Promise<Result<ChatHistoryDetail, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("load_chat_history", { clientId, chatId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get the current system prompt.
 * 
 * Returns the custom prompt from S3 if one exists, otherwise returns the
 * built-in default.
 */
async getSystemPrompt() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_system_prompt") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Save a custom system prompt to S3.
 * 
 * Overwrites any previously saved prompt. The new prompt takes effect on
 * the next chat message.
 */
async saveSystemPrompt(content: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("save_system_prompt", { content }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Delete the custom system prompt from S3, reverting to the built-in default.
 */
async deleteSystemPrompt() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_system_prompt") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
}
}

/** user-defined events **/



/** user-defined constants **/



/** user-defined types **/

/**
 * Metadata for an existing IAM access key.
 * 
 * Returned by [`list_user_access_keys`] so the operator can decide which
 * key to delete when the IAM 2-key limit is reached.
 */
export type AccessKeyInfo = { 
/**
 * The access key ID (e.g. `AKIA...`).
 */
access_key_id: string; 
/**
 * `"Active"` or `"Inactive"`.
 */
status: string; 
/**
 * When the key was created (ISO 8601).
 */
created_at: string | null; 
/**
 * When the key was last used (ISO 8601), or `None` if never used.
 */
last_used_at: string | null; 
/**
 * The AWS service the key was last used with (e.g. `"s3"`, `"iam"`),
 * or `None` if never used.
 */
last_used_service: string | null }
export type Action = "ok" | "create" | "modify" | "delete" | "precondition_failed"
/**
 * Temporary credentials obtained by assuming a role in a sub-account.
 * 
 * These are short-lived (typically 1 hour) and include a session token.
 * They should **never** be persisted to disk — they exist only to bootstrap
 * a dedicated IAM user in the sub-account.
 */
export type AssumeRoleResult = { 
/**
 * Temporary access key ID for the assumed role.
 */
access_key_id: string; 
/**
 * Temporary secret access key for the assumed role.
 */
secret_access_key: string; 
/**
 * Session token — required for all API calls made with these credentials.
 */
session_token: string; 
/**
 * When these temporary credentials expire (ISO 8601).
 */
expiration: string | null; 
/**
 * The ARN of the assumed role (e.g.
 * `arn:aws:sts::690641653532:assumed-role/OrganizationAccountAccessRole/claria-setup`).
 */
assumed_role_arn: string; 
/**
 * The account ID of the sub-account we assumed into.
 */
account_id: string }
/**
 * The result of a full bootstrap attempt.
 */
export type BootstrapResult = { success: boolean; steps: BootstrapStep[]; account_id: string | null; 
/**
 * The new, scoped credentials. `None` on failure.
 */
new_credentials: NewCredentials | null; error: string | null }
/**
 * A single step in the bootstrap sequence, reported for UI rendering.
 */
export type BootstrapStep = { name: string; status: StepStatus; detail: string | null }
/**
 * Identity information returned by STS `GetCallerIdentity`.
 */
export type CallerIdentity = { account_id: string; arn: string; user_id: string; is_root: boolean }
export type Cause = "in_sync" | "first_provision" | "drift" | "manifest_changed" | "orphaned"
/**
 * Detail of a persisted chat session, returned when resuming a conversation.
 */
export type ChatHistoryDetail = { chat_id: string; model_id: string; messages: ChatMessage[]; created_at: string }
export type ChatMessage = { role: ChatRole; content: string }
/**
 * Specta type mirroring `claria_bedrock::chat::ChatModel`.
 */
export type ChatModel = { model_id: string; name: string }
/**
 * Response from a chat message, including the persisted chat session ID.
 */
export type ChatResponse = { chat_id: string; content: string }
export type ChatRole = "user" | "assistant"
export type ClientSummary = { id: string; name: string; created_at: string }
/**
 * Redacted config info safe to send to the frontend.
 */
export type ConfigInfo = { region: string; system_name: string; account_id: string; created_at: string; credential_type: string; profile_name: string | null; access_key_hint: string | null }
/**
 * The result of `assess_credentials`.
 */
export type CredentialAssessment = { identity: CallerIdentity; credential_class: CredentialClass; 
/**
 * Human-readable explanation of why this class was chosen.
 */
reason: string }
/**
 * Classification of the credentials the operator provided.
 */
export type CredentialClass = 
/**
 * The AWS account root user. Has God-mode access but should never be
 * used for day-to-day operations. Bootstrap required.
 */
"root" | 
/**
 * An IAM principal (user or role) with broad permissions — at minimum
 * the ability to manage IAM users and policies. Bootstrap required to
 * create a scoped Claria user.
 */
"iam_admin" | 
/**
 * An IAM principal that already has the minimal Claria permissions.
 * Ready for resource provisioning.
 */
"scoped_claria" | 
/**
 * The credentials lack the permissions Claria needs and also lack the
 * IAM permissions required to self-bootstrap.
 */
"insufficient"
export type CredentialSource = { type: "inline"; access_key_id: string; secret_access_key: string; session_token?: string | null } | { type: "profile"; profile_name: string } | { type: "default_chain" }
/**
 * Structured before/after for a single field that doesn't match desired state.
 * 
 * Returned by `ResourceSyncer::diff()`. The frontend renders these directly
 * as before/after rows.
 */
export type FieldDrift = { 
/**
 * Machine-readable field name, e.g. "sse_algorithm"
 */
field: string; 
/**
 * Human-readable label, e.g. "Encryption algorithm"
 */
label: string; 
/**
 * What we want
 */
expected: JsonValue; 
/**
 * What AWS has
 */
actual: JsonValue }
export type JsonValue = null | boolean | number | string | JsonValue[] | Partial<{ [key in string]: JsonValue }>
export type Lifecycle = "data" | "managed"
/**
 * Fresh credentials created during the bootstrap flow.
 */
export type NewCredentials = { access_key_id: string; secret_access_key: string; iam_user_arn: string }
/**
 * A single entry in the plan — the spec annotated with what happened.
 * 
 * The plan is a flat `Vec<PlanEntry>` — same shape as the manifest array,
 * annotated with status. The entry embeds the full spec so the frontend
 * has everything it needs (label, description, severity, desired state)
 * without a separate lookup.
 */
export type PlanEntry = { spec: ResourceSpec; action: Action; cause: Cause; drift: FieldDrift[] }
/**
 * A record file with its readable text content, for chat context.
 */
export type RecordContext = { filename: string; text: string }
/**
 * A file in a client's record (S3 object metadata).
 */
export type RecordFile = { filename: string; size: number; uploaded_at: string | null }
/**
 * Every resource in the system is declared as a `ResourceSpec`.
 * 
 * The spec carries both the desired AWS state and the trust metadata
 * (label, description, severity, required IAM actions). This is the
 * single source of truth — the syncer, the plan, and the UI all read
 * from it.
 */
export type ResourceSpec = { 
/**
 * e.g. "s3_bucket", "baa_agreement"
 */
resource_type: string; 
/**
 * e.g. "123456789012-claria-data"
 */
resource_name: string; 
/**
 * Data (read-only precondition) or Managed (Claria creates/updates/deletes)
 */
lifecycle: Lifecycle; 
/**
 * The desired AWS state as a JSON value — shape varies per resource type
 */
desired: JsonValue; 
/**
 * Short label for the UI, e.g. "S3 Bucket Encryption"
 */
label: string; 
/**
 * Human-readable purpose, e.g. "Server-side encryption — your data is encrypted at rest"
 */
description: string; 
/**
 * How much attention this entry needs
 */
severity: Severity; 
/**
 * IAM actions this resource requires (aggregated for policy diff)
 */
iam_actions: string[] }
export type Severity = 
/**
 * Data sources — read-only checks
 */
"info" | 
/**
 * Routine infra (S3 settings, CloudTrail)
 */
"normal" | 
/**
 * Requires acknowledgment (BAA, model agreements)
 */
"elevated" | 
/**
 * Data loss risk (bucket deletion during orphan cleanup)
 */
"destructive"
/**
 * Status of an individual bootstrap step.
 */
export type StepStatus = "pending" | "in_progress" | "succeeded" | "failed"

/** tauri-specta globals **/

import {
	invoke as TAURI_INVOKE,
	Channel as TAURI_CHANNEL,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
	listen: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
	once: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
	emit: null extends T
		? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
		: (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
	| { status: "ok"; data: T }
	| { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(
	mappings: Record<keyof T, string>,
) {
	return new Proxy(
		{} as unknown as {
			[K in keyof T]: __EventObj__<T[K]> & {
				(handle: __WebviewWindow__): __EventObj__<T[K]>;
			};
		},
		{
			get: (_, event) => {
				const name = mappings[event as keyof T];

				return new Proxy((() => {}) as any, {
					apply: (_, __, [window]: [__WebviewWindow__]) => ({
						listen: (arg: any) => window.listen(name, arg),
						once: (arg: any) => window.once(name, arg),
						emit: (arg: any) => window.emit(name, arg),
					}),
					get: (_, command: keyof __EventObj__<any>) => {
						switch (command) {
							case "listen":
								return (arg: any) => TAURI_API_EVENT.listen(name, arg);
							case "once":
								return (arg: any) => TAURI_API_EVENT.once(name, arg);
							case "emit":
								return (arg: any) => TAURI_API_EVENT.emit(name, arg);
						}
					},
				});
			},
		},
	);
}
