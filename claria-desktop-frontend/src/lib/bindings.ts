// @ts-nocheck

// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/


export const commands = {
async hasConfig() : Promise<Result<boolean, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("has_config") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async loadConfig() : Promise<Result<ConfigInfo, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("load_config") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async saveConfig(region: string, systemName: string, accountId: string, credentials: CredentialSource) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("save_config", { region, systemName, accountId, credentials }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async deleteConfig() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_config") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Assess the provided credentials: validates them via STS and classifies
 * them as root / IAM admin / scoped Claria / insufficient.
 * 
 * The desktop app uses the returned `CredentialAssessment` to decide
 * which UI flow to present (bootstrap vs. straight to provisioning).
 */
async assessCredentials(region: string, credentials: CredentialSource) : Promise<Result<CredentialAssessment, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("assess_credentials", { region, credentials }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Assume a role in an AWS sub-account using parent-account credentials.
 * 
 * The operator provides their parent-account credentials and the sub-account
 * details. We call STS AssumeRole and return temporary credentials that can
 * be used with `assess_credentials` and `bootstrap_iam_user` to set up a
 * dedicated IAM user in the sub-account.
 * 
 * The temporary credentials are never persisted to disk.
 */
async assumeRole(region: string, credentials: CredentialSource, accountId: string, roleName: string) : Promise<Result<AssumeRoleResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("assume_role", { region, credentials, accountId, roleName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async listAwsProfiles() : Promise<Result<string[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_aws_profiles") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * List all access keys for the `claria-admin` IAM user, enriched with
 * last-used metadata.
 * 
 * Called when bootstrap fails due to the 2-key limit so the operator can
 * pick which key to delete.
 */
async listUserAccessKeys(region: string, credentials: CredentialSource) : Promise<Result<AccessKeyInfo[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_user_access_keys", { region, credentials }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Delete one access key belonging to the `claria-admin` IAM user.
 * 
 * Called after the operator picks a key to remove to make room for a
 * fresh one during bootstrap.
 */
async deleteUserAccessKey(region: string, credentials: CredentialSource, accessKeyId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_user_access_key", { region, credentials, accessKeyId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Run the full bootstrap flow: create a scoped IAM user and policy using
 * the operator's current (broad) credentials, then persist the new scoped
 * credentials to the local config.
 * 
 * The provisioner does all the IAM work and returns the new credentials.
 * We handle only the config write and in-memory state update.
 */
async bootstrapIamUser(region: string, systemName: string, rootAccessKeyId: string, rootSecretAccessKey: string, sessionToken: string | null, credentialClass: CredentialClass) : Promise<Result<BootstrapResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("bootstrap_iam_user", { region, systemName, rootAccessKeyId, rootSecretAccessKey, sessionToken, credentialClass }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Scan all managed AWS resources and return their current state.
 * 
 * This is a read-only operation — no resources are created or modified.
 * The frontend renders the results as a status table before prompting
 * the operator to review a plan.
 */
async scanResources() : Promise<Result<ScanResult[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("scan_resources") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Scan resources, compare against persisted state, and return a four-bucket
 * plan (ok / modify / create / delete) without executing anything.
 * 
 * The frontend renders the plan for operator review before provisioning.
 */
async previewPlan() : Promise<Result<Plan, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("preview_plan") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Execute the full scan → plan → execute pipeline.
 * 
 * Returns the plan that was executed so the frontend can show a summary.
 * State is flushed to local disk + S3 after each resource action.
 */
async provision() : Promise<Result<Plan, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("provision") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Destroy all managed resources and clear provisioner state.
 * 
 * The operator's config is NOT deleted — only the AWS resources and
 * the provisioner state file. The operator can re-provision later.
 */
async destroy() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("destroy") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * List all client records from S3.
 * 
 * Loads each `clients/{id}.json` object, deserializes the Client, and
 * returns summaries sorted by most recently created first.
 */
async listClients() : Promise<Result<ClientSummary[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_clients") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Create a new client record in S3.
 */
async createClient(name: string) : Promise<Result<ClientSummary, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_client", { name }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * List files in a client's record, excluding sidecar `.text` files.
 */
async listRecordFiles(clientId: string) : Promise<Result<RecordFile[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_record_files", { clientId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Upload a file to a client's record from a local file path.
 */
async uploadRecordFile(clientId: string, filePath: string) : Promise<Result<RecordFile, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("upload_record_file", { clientId, filePath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Delete a file from a client's record, including its sidecar if present.
 */
async deleteRecordFile(clientId: string, filename: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_record_file", { clientId, filename }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get the extracted text for a record file (from its `.text` sidecar).
 */
async getRecordFileText(clientId: string, filename: string) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_record_file_text", { clientId, filename }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * List available Anthropic Claude models for chat.
 * 
 * Queries Bedrock for system-defined inference profiles and returns
 * those matching Anthropic Claude models.
 */
async listChatModels() : Promise<Result<ChatModel[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_chat_models") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Send a chat message to Bedrock and return the assistant's response.
 * 
 * The frontend maintains the full conversation history and sends it
 * with each request so the model has context. The system prompt is
 * fetched from S3 on each call so edits take effect immediately.
 */
async chatMessage(modelId: string, messages: ChatMessage[]) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("chat_message", { modelId, messages }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Accept the Marketplace agreement for a Bedrock foundation model.
 * 
 * Called when a model requires an agreement before it can be used.
 * The frontend can detect this from the error message and offer
 * a one-click accept flow.
 */
async acceptModelAgreement(modelId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("accept_model_agreement", { modelId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get the current system prompt.
 * 
 * Returns the custom prompt from S3 if one exists, otherwise returns the
 * built-in default.
 */
async getSystemPrompt() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_system_prompt") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Save a custom system prompt to S3.
 * 
 * Overwrites any previously saved prompt. The new prompt takes effect on
 * the next chat message.
 */
async saveSystemPrompt(content: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("save_system_prompt", { content }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Delete the custom system prompt from S3, reverting to the built-in default.
 */
async deleteSystemPrompt() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_system_prompt") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
}
}

/** user-defined events **/



/** user-defined constants **/



/** user-defined types **/

/**
 * Metadata for an existing IAM access key.
 * 
 * Returned by [`list_user_access_keys`] so the operator can decide which
 * key to delete when the IAM 2-key limit is reached.
 */
export type AccessKeyInfo = { 
/**
 * The access key ID (e.g. `AKIA...`).
 */
access_key_id: string; 
/**
 * `"Active"` or `"Inactive"`.
 */
status: string; 
/**
 * When the key was created (ISO 8601).
 */
created_at: string | null; 
/**
 * When the key was last used (ISO 8601), or `None` if never used.
 */
last_used_at: string | null; 
/**
 * The AWS service the key was last used with (e.g. `"s3"`, `"iam"`),
 * or `None` if never used.
 */
last_used_service: string | null }
/**
 * Temporary credentials obtained by assuming a role in a sub-account.
 * 
 * These are short-lived (typically 1 hour) and include a session token.
 * They should **never** be persisted to disk — they exist only to bootstrap
 * a dedicated IAM user in the sub-account.
 */
export type AssumeRoleResult = { 
/**
 * Temporary access key ID for the assumed role.
 */
access_key_id: string; 
/**
 * Temporary secret access key for the assumed role.
 */
secret_access_key: string; 
/**
 * Session token — required for all API calls made with these credentials.
 */
session_token: string; 
/**
 * When these temporary credentials expire (ISO 8601).
 */
expiration: string | null; 
/**
 * The ARN of the assumed role (e.g.
 * `arn:aws:sts::690641653532:assumed-role/OrganizationAccountAccessRole/claria-setup`).
 */
assumed_role_arn: string; 
/**
 * The account ID of the sub-account we assumed into.
 */
account_id: string }
/**
 * The result of a full bootstrap attempt.
 */
export type BootstrapResult = { success: boolean; steps: BootstrapStep[]; account_id: string | null; 
/**
 * The new, scoped credentials. `None` on failure.
 */
new_credentials: NewCredentials | null; error: string | null }
/**
 * A single step in the bootstrap sequence, reported for UI rendering.
 */
export type BootstrapStep = { name: string; status: StepStatus; detail: string | null }
/**
 * Identity information returned by STS `GetCallerIdentity`.
 */
export type CallerIdentity = { account_id: string; arn: string; user_id: string; is_root: boolean }
export type ChatMessage = { role: ChatRole; content: string }
/**
 * Specta type mirroring `claria_bedrock::chat::ChatModel`.
 */
export type ChatModel = { model_id: string; name: string }
export type ChatRole = "user" | "assistant"
export type ClientSummary = { id: string; name: string; created_at: string }
/**
 * Redacted config info safe to send to the frontend.
 */
export type ConfigInfo = { region: string; system_name: string; account_id: string; created_at: string; credential_type: string; profile_name: string | null; access_key_hint: string | null }
/**
 * The result of `assess_credentials`.
 */
export type CredentialAssessment = { identity: CallerIdentity; credential_class: CredentialClass; 
/**
 * Human-readable explanation of why this class was chosen.
 */
reason: string }
/**
 * Classification of the credentials the operator provided.
 */
export type CredentialClass = 
/**
 * The AWS account root user. Has God-mode access but should never be
 * used for day-to-day operations. Bootstrap required.
 */
"root" | 
/**
 * An IAM principal (user or role) with broad permissions — at minimum
 * the ability to manage IAM users and policies. Bootstrap required to
 * create a scoped Claria user.
 */
"iam_admin" | 
/**
 * An IAM principal that already has the minimal Claria permissions.
 * Ready for resource provisioning.
 */
"scoped_claria" | 
/**
 * The credentials lack the permissions Claria needs and also lack the
 * IAM permissions required to self-bootstrap.
 */
"insufficient"
export type CredentialSource = { type: "inline"; access_key_id: string; secret_access_key: string; session_token?: string | null } | { type: "profile"; profile_name: string } | { type: "default_chain" }
export type JsonValue = null | boolean | number | string | JsonValue[] | Partial<{ [key in string]: JsonValue }>
/**
 * Fresh credentials created during the bootstrap flow.
 */
export type NewCredentials = { access_key_id: string; secret_access_key: string; iam_user_arn: string }
/**
 * A provisioning plan with four categorized buckets.
 * 
 * The desktop UI renders these as color-coded lists:
 * - `ok` (green) — resources in good shape, no action needed
 * - `modify` (yellow) — resources that need updating (e.g. missing encryption)
 * - `create` (blue) — resources that don't exist yet
 * - `delete` (red) — stale state entries to clean up
 */
export type Plan = { ok: PlanEntry[]; modify: PlanEntry[]; create: PlanEntry[]; delete: PlanEntry[] }
/**
 * A single entry in a provisioning plan.
 */
export type PlanEntry = { resource_type: string; resource_id: string; reason: string }
/**
 * A file in a client's record (S3 object metadata).
 */
export type RecordFile = { filename: string; size: number; uploaded_at: string | null }
/**
 * Result of scanning a single resource in AWS.
 */
export type ScanResult = { resource_type: string; status: ScanStatus; resource_id: string | null; properties: JsonValue | null; error: string | null }
/**
 * The status of a single resource after scanning AWS.
 */
export type ScanStatus = "found" | "not_found" | "error"
/**
 * Status of an individual bootstrap step.
 */
export type StepStatus = "pending" | "in_progress" | "succeeded" | "failed"

/** tauri-specta globals **/

import {
	invoke as TAURI_INVOKE,
	Channel as TAURI_CHANNEL,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
	listen: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
	once: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
	emit: null extends T
		? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
		: (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
	| { status: "ok"; data: T }
	| { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(
	mappings: Record<keyof T, string>,
) {
	return new Proxy(
		{} as unknown as {
			[K in keyof T]: __EventObj__<T[K]> & {
				(handle: __WebviewWindow__): __EventObj__<T[K]>;
			};
		},
		{
			get: (_, event) => {
				const name = mappings[event as keyof T];

				return new Proxy((() => {}) as any, {
					apply: (_, __, [window]: [__WebviewWindow__]) => ({
						listen: (arg: any) => window.listen(name, arg),
						once: (arg: any) => window.once(name, arg),
						emit: (arg: any) => window.emit(name, arg),
					}),
					get: (_, command: keyof __EventObj__<any>) => {
						switch (command) {
							case "listen":
								return (arg: any) => TAURI_API_EVENT.listen(name, arg);
							case "once":
								return (arg: any) => TAURI_API_EVENT.once(name, arg);
							case "emit":
								return (arg: any) => TAURI_API_EVENT.emit(name, arg);
						}
					},
				});
			},
		},
	);
}
